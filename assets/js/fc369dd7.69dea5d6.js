"use strict";(self.webpackChunksynapseml=self.webpackChunksynapseml||[]).push([[426],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return m}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=p(n),m=i,f=u["".concat(s,".").concat(m)]||u[m]||d[m]||l;return n?a.createElement(f,r(r({ref:t},c),{},{components:n})):a.createElement(f,r({ref:t},c))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,r=new Array(l);r[0]=u;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,r[1]=o;for(var p=2;p<l;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},1608:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return c},default:function(){return u}});var a=n(3117),i=n(102),l=(n(7294),n(3905)),r=["components"],o={title:"Interpretability - PDP and ICE explainer",hide_title:!0,status:"stable",name:"Interpretability - PDP and ICE explainer"},s=void 0,p={unversionedId:"features/responsible_ai/Interpretability - PDP and ICE explainer",id:"features/responsible_ai/Interpretability - PDP and ICE explainer",title:"Interpretability - PDP and ICE explainer",description:"Partial Dependence (PDP) and Individual Conditional Expectation (ICE) plots",source:"@site/docs/features/responsible_ai/Interpretability - PDP and ICE explainer.md",sourceDirName:"features/responsible_ai",slug:"/features/responsible_ai/Interpretability - PDP and ICE explainer",permalink:"/SynapseML/docs/next/features/responsible_ai/Interpretability - PDP and ICE explainer",tags:[],version:"current",frontMatter:{title:"Interpretability - PDP and ICE explainer",hide_title:!0,status:"stable"},sidebar:"docs",previous:{title:"Interpretability - Image Explainers",permalink:"/SynapseML/docs/next/features/responsible_ai/Interpretability - Image Explainers"},next:{title:"Interpretability - Snow Leopard Detection",permalink:"/SynapseML/docs/next/features/responsible_ai/Interpretability - Snow Leopard Detection"}},c=[{value:"Partial Dependence (PDP) and Individual Conditional Expectation (ICE) plots",id:"partial-dependence-pdp-and-individual-conditional-expectation-ice-plots",children:[{value:"Read and prepare the dataset",id:"read-and-prepare-the-dataset",children:[],level:3},{value:"Fit the model and view the predictions",id:"fit-the-model-and-view-the-predictions",children:[],level:3}],level:2},{value:"Partial Dependence Plots",id:"partial-dependence-plots",children:[{value:"Setup the transformer for PDP",id:"setup-the-transformer-for-pdp",children:[],level:3},{value:"Visualization",id:"visualization",children:[{value:"Example 1: &quot;age&quot;",id:"example-1-age",children:[],level:4},{value:"Example 2: &quot;marital-status&quot;",id:"example-2-marital-status",children:[],level:4},{value:"Example 3: &quot;capital-gain&quot;",id:"example-3-capital-gain",children:[],level:4}],level:3},{value:"Conclusions",id:"conclusions",children:[],level:3}],level:2},{value:"Individual Conditional Expectation",id:"individual-conditional-expectation",children:[{value:"Setup the transformer for ICE",id:"setup-the-transformer-for-ice",children:[],level:3},{value:"Visualization",id:"visualization-1",children:[{value:"Example 1: Numeric feature: &quot;age&quot;",id:"example-1-numeric-feature-age",children:[],level:4},{value:"Example 2: Categorical feature: &quot;occupation&quot;",id:"example-2-categorical-feature-occupation",children:[],level:4}],level:3},{value:"Conclusions",id:"conclusions-1",children:[],level:3}],level:2},{value:"Overall conclusions",id:"overall-conclusions",children:[],level:2}],d={toc:c};function u(e){var t=e.components,n=(0,i.Z)(e,r);return(0,l.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"partial-dependence-pdp-and-individual-conditional-expectation-ice-plots"},"Partial Dependence (PDP) and Individual Conditional Expectation (ICE) plots"),(0,l.kt)("p",null,"Partial Dependence Plot (PDP) and Individual Condition Expectation (ICE) are interpretation methods which describe the average behavior of a classification or regression model. They are particularly useful when the model developer wants to understand generally how the model depends on individual feature values, overall model behavior and do debugging."),(0,l.kt)("p",null,"In terms of ",(0,l.kt)("a",{parentName:"p",href:"https://www.microsoft.com/en-us/ai/responsible-ai"},"Responsible AI"),", understanding which features drive your predictions facilitate the creation of ",(0,l.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/legal/cognitive-services/language-service/transparency-note"},"Transparency Notes"),", driving not only transparency but accountability while facilitating auditing to meet compliance with regulatory requirements."),(0,l.kt)("p",null,"The goal of this notebook is to show how these methods work for a pretrained model."),(0,l.kt)("p",null,"In this example, we train a classification model with the Adult Census Income dataset. Then we treat the model as an opaque-box model and calculate the PDP and ICE plots for some selected categorical and numeric features. "),(0,l.kt)("p",null,"This dataset can be used to predict whether annual income exceeds $50,000/year or not based on demographic data from the 1994 U.S. Census. The dataset we're reading contains 32,561 rows and 14 columns/features."),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"https://archive.ics.uci.edu/ml/datasets/Adult"},"More info on the dataset here")),(0,l.kt)("p",null,"We will train a classification model to predict >= 50K or < 50K based on our features."),(0,l.kt)("hr",null),(0,l.kt)("p",null,"Python dependencies:"),(0,l.kt)("p",null,"matplotlib==3.2.2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"from pyspark.ml import Pipeline\nfrom pyspark.ml.classification import GBTClassifier\nfrom pyspark.ml.feature import VectorAssembler, StringIndexer, OneHotEncoder\nimport pyspark.sql.functions as F\nfrom pyspark.ml.evaluation import BinaryClassificationEvaluator\n\nfrom synapse.ml.explainers import ICETransformer\n\nimport matplotlib.pyplot as plt\n")),(0,l.kt)("h3",{id:"read-and-prepare-the-dataset"},"Read and prepare the dataset"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'df = spark.read.parquet("wasbs://publicwasb@mmlspark.blob.core.windows.net/AdultCensusIncome.parquet")\ndisplay(df)\n')),(0,l.kt)("h3",{id:"fit-the-model-and-view-the-predictions"},"Fit the model and view the predictions"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'categorical_features = ["race", "workclass", "marital-status", "education", "occupation", "relationship", "native-country", "sex"]\nnumeric_features = ["age", "education-num", "capital-gain", "capital-loss", "hours-per-week"]\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'string_indexer_outputs = [feature + "_idx" for feature in categorical_features]\none_hot_encoder_outputs = [feature + "_enc" for feature in categorical_features]\n\npipeline = Pipeline(stages=[\n    StringIndexer().setInputCol("income").setOutputCol("label").setStringOrderType("alphabetAsc"),\n    StringIndexer().setInputCols(categorical_features).setOutputCols(string_indexer_outputs),\n    OneHotEncoder().setInputCols(string_indexer_outputs).setOutputCols(one_hot_encoder_outputs),\n    VectorAssembler(inputCols=one_hot_encoder_outputs+numeric_features, outputCol="features"),\n    GBTClassifier(weightCol="fnlwgt", maxDepth=7, maxIter=100)])\n\nmodel = pipeline.fit(df)\n')),(0,l.kt)("p",null,"Check that model makes sense and has reasonable output. For this, we will check the model performance by calculating the ROC-AUC score."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"data = model.transform(df)\ndisplay(data.select('income', 'probability', 'prediction'))\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'eval_auc = BinaryClassificationEvaluator(labelCol="label", rawPredictionCol="prediction")\neval_auc.evaluate(data)\n')),(0,l.kt)("h2",{id:"partial-dependence-plots"},"Partial Dependence Plots"),(0,l.kt)("p",null,"Partial dependence plots (PDP) show the dependence between the target response and a set of input features of interest, marginalizing over the values of all other input features. It can show whether the relationship between the target response and the input feature is linear, smooth, monotonic, or more complex. This is relevant when you want to have an overall understanding of model behavior. E.g. Identifying specific age group have a favorable predictions vs other age groups."),(0,l.kt)("p",null,"If you want to learn more please visit ",(0,l.kt)("a",{parentName:"p",href:"https://scikit-learn.org/stable/modules/partial_dependence.html#partial-dependence-plots"},"this link"),"."),(0,l.kt)("h3",{id:"setup-the-transformer-for-pdp"},"Setup the transformer for PDP"),(0,l.kt)("p",null,"To plot PDP we need to set up the instance of ",(0,l.kt)("inlineCode",{parentName:"p"},"ICETransformer")," first and set the ",(0,l.kt)("inlineCode",{parentName:"p"},"kind")," parameter to ",(0,l.kt)("inlineCode",{parentName:"p"},"average")," and then call the ",(0,l.kt)("inlineCode",{parentName:"p"},"transform")," function. "),(0,l.kt)("p",null,'For the setup we need to pass the pretrained model, specify the target column ("probability" in our case), and pass categorical and numeric feature names.'),(0,l.kt)("p",null,"Categorical and numeric features can be passed as a list of names. But we can specify parameters for the features by passing a list of dicts where each dict represents one feature. "),(0,l.kt)("p",null,"For the numeric features a dictionary can look like this:"),(0,l.kt)("p",null,'{"name": "capital-gain", "numSplits": 20, "rangeMin": 0.0, "rangeMax": 10000.0, "outputColName": "capital-gain_dependance"}'),(0,l.kt)("p",null,"Where the required key-value pair is ",(0,l.kt)("inlineCode",{parentName:"p"},"name")," -  the name of the numeric feature. Next key-values pairs are optional: ",(0,l.kt)("inlineCode",{parentName:"p"},"numSplits")," - the number of splits for the value range for the numeric feature (default value is 10), ",(0,l.kt)("inlineCode",{parentName:"p"},"rangeMin")," - specifies the min value of the range for the numeric feature, ",(0,l.kt)("inlineCode",{parentName:"p"},"rangeMax")," - specifies the max value of the range for the numeric feature (if not specified, ",(0,l.kt)("inlineCode",{parentName:"p"},"rangeMin")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"rangeMax")," will be computed from the background dataset), ",(0,l.kt)("inlineCode",{parentName:"p"},"outputColName"),' - the name for output column with explanations for the feature (default value is input name of the feature + "_dependence").'),(0,l.kt)("p",null,"For the categorical features a dictionary can look like this:"),(0,l.kt)("p",null,'{"name": "marital-status", "numTopValues": 10, "outputColName": "marital-status_dependance"}'),(0,l.kt)("p",null,"Where the required key-value pair is ",(0,l.kt)("inlineCode",{parentName:"p"},"name")," -  the name of the numeric feature. Next key-values pairs are optional: ",(0,l.kt)("inlineCode",{parentName:"p"},"numTopValues")," - the max number of top-occurring values to be included in the categorical feature (default value is 100), ",(0,l.kt)("inlineCode",{parentName:"p"},"outputColName")," - the name for output column with explanations for the feature (default value is input name of the feature + _dependence)."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'pdp = ICETransformer(model=model, targetCol="probability", kind="average", targetClasses=[1],\n                     categoricalFeatures=categorical_features, numericFeatures=numeric_features)\n')),(0,l.kt)("p",null,"PDP transformer returns a dataframe of 1 row * {number features to explain} columns. Each column contains a map between the feature's values and the model's average dependence for the that feature value."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"output_pdp = pdp.transform(df)\ndisplay(output_pdp)\n")),(0,l.kt)("h3",{id:"visualization"},"Visualization"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'# Helper functions for visualization\n\ndef get_pandas_df_from_column(df, col_name):\n  keys_df = df.select(F.explode(F.map_keys(F.col(col_name)))).distinct()\n  keys = list(map(lambda row: row[0], keys_df.collect()))\n  key_cols = list(map(lambda f: F.col(col_name).getItem(f).alias(str(f)), keys))\n  final_cols = key_cols\n  pandas_df = df.select(final_cols).toPandas()\n  return pandas_df\n\ndef plot_dependence_for_categorical(df, col, col_int=True, figsize=(20, 5)):\n  dict_values = {}\n  col_names = list(df.columns)\n\n  for col_name in col_names:\n    dict_values[col_name] = df[col_name][0].toArray()[0]\n    marklist= sorted(dict_values.items(), key=lambda x: int(x[0]) if col_int else x[0]) \n    sortdict=dict(marklist)\n\n  fig = plt.figure(figsize = figsize)\n  plt.bar(sortdict.keys(), sortdict.values())\n\n  plt.xlabel(col, size=13)\n  plt.ylabel("Dependence")\n  plt.show()\n  \ndef plot_dependence_for_numeric(df, col, col_int=True, figsize=(20, 5)):\n  dict_values = {}\n  col_names = list(df.columns)\n\n  for col_name in col_names:\n    dict_values[col_name] = df[col_name][0].toArray()[0]\n    marklist= sorted(dict_values.items(), key=lambda x: int(x[0]) if col_int else x[0]) \n    sortdict=dict(marklist)\n\n  fig = plt.figure(figsize = figsize)\n\n  \n  plt.plot(list(sortdict.keys()), list(sortdict.values()))\n\n  plt.xlabel(col, size=13)\n  plt.ylabel("Dependence")\n  plt.ylim(0.0)\n  plt.show()\n  \n')),(0,l.kt)("h4",{id:"example-1-age"},'Example 1: "age"'),(0,l.kt)("p",null,"We can observe non-linear dependency. The model predicts that income rapidly grows from 24-46 y.o. age, after 46 y.o. model predictions slightly drops and from 68 y.o. remains stable."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"df_education_num = get_pandas_df_from_column(output_pdp, 'age_dependence')\nplot_dependence_for_numeric(df_education_num, 'age')\n")),(0,l.kt)("p",null,"Your results will look like:"),(0,l.kt)("p",null,(0,l.kt)("img",{parentName:"p",src:"https://mmlspark.blob.core.windows.net/graphics/explainers/pdp_age.png",alt:"pdp_age"})),(0,l.kt)("h4",{id:"example-2-marital-status"},'Example 2: "marital-status"'),(0,l.kt)("p",null,'The model seems to treat "married-cv-spouse" as one category and tend to give a higher average prediction, and all others as a second category with the lower average prediction.'),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"df_occupation = get_pandas_df_from_column(output_pdp, 'marital-status_dependence')\nplot_dependence_for_categorical(df_occupation, 'marital-status', False, figsize=(30, 5))\n")),(0,l.kt)("p",null,"Your results will look like:\n",(0,l.kt)("img",{parentName:"p",src:"https://mmlspark.blob.core.windows.net/graphics/explainers/pdp_marital-status.png",alt:"pdp_marital-status"})),(0,l.kt)("h4",{id:"example-3-capital-gain"},'Example 3: "capital-gain"'),(0,l.kt)("p",null,"In the first graph, we run PDP with default parameters. We can see that this representation is not super useful because it is not granular enough. By default the range of numeric features are calculated dynamically from the data."),(0,l.kt)("p",null,"In the second graph, we set rangeMin = 0 and rangeMax = 10000 to visualize more granular interpretations for the feature of interest. Now we can see more clearly how the model made decisions in a smaller region."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"df_education_num = get_pandas_df_from_column(output_pdp, 'capital-gain_dependence')\nplot_dependence_for_numeric(df_education_num, 'capital-gain_dependence')\n")),(0,l.kt)("p",null,"Your results will look like:"),(0,l.kt)("p",null,(0,l.kt)("img",{parentName:"p",src:"https://mmlspark.blob.core.windows.net/graphics/explainers/pdp_capital-gain-first.png",alt:"pdp_capital-gain-first"})),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'pdp_cap_gain = ICETransformer(model=model, targetCol="probability", kind="average", targetClasses=[1], \n                              numericFeatures=[{"name": "capital-gain", "numSplits": 20, "rangeMin": 0.0,\n                                                 "rangeMax": 10000.0}], numSamples=50)\noutput_pdp_cap_gain = pdp_cap_gain.transform(df)\ndf_education_num_gain = get_pandas_df_from_column(output_pdp_cap_gain, \'capital-gain_dependence\')\nplot_dependence_for_numeric(df_education_num_gain, \'capital-gain_dependence\')\n')),(0,l.kt)("p",null,"Your results will look like:"),(0,l.kt)("p",null,(0,l.kt)("img",{parentName:"p",src:"https://mmlspark.blob.core.windows.net/graphics/explainers/pdp_capital-gain-second.png",alt:"pdp_capital-gain-second"})),(0,l.kt)("h3",{id:"conclusions"},"Conclusions"),(0,l.kt)("p",null,"PDP can be used to show how features influences model predictions on average and help modeler catch unexpected behavior from the model."),(0,l.kt)("h2",{id:"individual-conditional-expectation"},"Individual Conditional Expectation"),(0,l.kt)("p",null,"ICE plots display one line per instance that shows how the instance\u2019s prediction changes when a feature values changes. Each line represents the predictions for one instance if we vary the feature of interest. This is relevant when you want to observe model prediction for instances individually in more details. "),(0,l.kt)("p",null,"If you want to learn more please visit ",(0,l.kt)("a",{parentName:"p",href:"https://scikit-learn.org/stable/modules/partial_dependence.html#individual-conditional-expectation-ice-plot"},"this link"),"."),(0,l.kt)("h3",{id:"setup-the-transformer-for-ice"},"Setup the transformer for ICE"),(0,l.kt)("p",null,"To plot ICE we need to set up the instance of ",(0,l.kt)("inlineCode",{parentName:"p"},"ICETransformer")," first and set the ",(0,l.kt)("inlineCode",{parentName:"p"},"kind")," parameter to ",(0,l.kt)("inlineCode",{parentName:"p"},"individual")," and then call the ",(0,l.kt)("inlineCode",{parentName:"p"},"transform"),' function. For the setup we need to pass the pretrained model, specify the target column ("probability" in our case), and pass categorical and numeric feature names. For better visualization we set the number of samples to 50.'),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'ice = ICETransformer(model=model, targetCol="probability", targetClasses=[1], \n                     categoricalFeatures=categorical_features, numericFeatures=numeric_features, numSamples=50)\n\noutput = ice.transform(df)\n')),(0,l.kt)("h3",{id:"visualization-1"},"Visualization"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'# Helper functions for visualization\nfrom math import pi\n\nfrom collections import defaultdict\n\ndef plot_ice_numeric(df, col, col_int=True, figsize=(20, 10)):\n  dict_values = defaultdict(list)\n  col_names = list(df.columns)\n  num_instances = df.shape[0]\n  \n  instances_y = {}\n  i = 0\n\n  for col_name in col_names:\n    for i in range(num_instances):\n      dict_values[i].append(df[col_name][i].toArray()[0])\n  \n  fig = plt.figure(figsize = figsize)\n  for i in range(num_instances):\n    plt.plot(col_names, dict_values[i], "k")\n  \n  \n  plt.xlabel(col, size=13)\n  plt.ylabel("Dependence")\n  plt.ylim(0.0)\n  \n  \n  \ndef plot_ice_categorical(df, col, col_int=True, figsize=(20, 10)):\n  dict_values = defaultdict(list)\n  col_names = list(df.columns)\n  num_instances = df.shape[0]\n  \n  angles = [n / float(df.shape[1]) * 2 * pi for n in range(df.shape[1])]\n  angles += angles [:1]\n  \n  instances_y = {}\n  i = 0\n\n  for col_name in col_names:\n    for i in range(num_instances):\n      dict_values[i].append(df[col_name][i].toArray()[0])\n  \n  fig = plt.figure(figsize = figsize)\n  ax = plt.subplot(111, polar=True)\n  plt.xticks(angles[:-1], col_names)\n  \n  for i in range(num_instances):\n    values = dict_values[i]\n    values += values[:1]\n    ax.plot(angles, values, "k")\n    ax.fill(angles, values, \'teal\', alpha=0.1)\n\n  plt.xlabel(col, size=13)\n  plt.show()\n\ndef overlay_ice_with_pdp(df_ice, df_pdp, col, col_int=True, figsize=(20, 5)):\n  dict_values = defaultdict(list)\n  col_names_ice = list(df_ice.columns)\n  num_instances = df_ice.shape[0]\n  \n  instances_y = {}\n  i = 0\n\n  for col_name in col_names_ice:\n    for i in range(num_instances):\n      dict_values[i].append(df_ice[col_name][i].toArray()[0])\n  \n  fig = plt.figure(figsize = figsize)\n  for i in range(num_instances):\n    plt.plot(col_names_ice, dict_values[i], "k")\n    \n  dict_values_pdp = {}\n  col_names = list(df_pdp.columns)\n\n  for col_name in col_names:\n    dict_values_pdp[col_name] = df_pdp[col_name][0].toArray()[0]\n    marklist= sorted(dict_values_pdp.items(), key=lambda x: int(x[0]) if col_int else x[0]) \n    sortdict=dict(marklist)\n  \n  plt.plot(col_names_ice, list(sortdict.values()), "r", linewidth=5)\n  \n  \n  \n  plt.xlabel(col, size=13)\n  plt.ylabel("Dependence")\n  plt.ylim(0.0)\n  plt.show()\n\n')),(0,l.kt)("h4",{id:"example-1-numeric-feature-age"},'Example 1: Numeric feature: "age"'),(0,l.kt)("p",null,'We can overlay the PDP on top of ICE plots. In the graph, the red line shows the PDP plot for the "age" feature, and the black lines show ICE plots for 50 randomly selected observations. '),(0,l.kt)("p",null,'The visualization will show that all curves follow a similar course. That means that the PDP (red line) is already a good summary of the relationships between the displayed feature "age" and the model\'s average predictions of "income"'),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"age_df_ice = get_pandas_df_from_column(output, 'age_dependence')\nage_df_pdp = get_pandas_df_from_column(output_pdp, 'age_dependence')\n\noverlay_ice_with_pdp(age_df_ice, age_df_pdp, col='age_dependence', figsize=(30, 10))\n")),(0,l.kt)("p",null,"Your results will look like:\n",(0,l.kt)("img",{parentName:"p",src:"https://mmlspark.blob.core.windows.net/graphics/explainers/pdp_age_overlayed.png",alt:"pdp_age_overlayed"})),(0,l.kt)("h4",{id:"example-2-categorical-feature-occupation"},'Example 2: Categorical feature: "occupation"'),(0,l.kt)("p",null,"For visualization of categorical features, we are using a star plot."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The X-axis here is a circle which is splitted into equal parts, each representing a feature value."),(0,l.kt)("li",{parentName:"ul"},"The Y-coordinate shows the dependence values. Each line represents a sample observation.")),(0,l.kt)("p",null,'Here we can see that "Farming-fishing" drives the least predictions - because values accumulated near the lowest probabilities, but, for example, "Exec-managerial" seems to have one of the highest impacts for model predictions.'),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"occupation_dep = get_pandas_df_from_column(output, 'occupation_dependence')\n\nplot_ice_categorical(occupation_dep, 'occupation_dependence', figsize=(30, 10))\n")),(0,l.kt)("p",null,"Your results will look like:"),(0,l.kt)("p",null,(0,l.kt)("img",{parentName:"p",src:"https://mmlspark.blob.core.windows.net/graphics/explainers/pdp_occupation-star-plot.png",alt:"pdp_occupation-star-plot"})),(0,l.kt)("h3",{id:"conclusions-1"},"Conclusions"),(0,l.kt)("p",null,"ICE plots show model behavior on individual observations. Each line represents the prediction from the model if we vary the feature of interest."),(0,l.kt)("h2",{id:"overall-conclusions"},"Overall conclusions"),(0,l.kt)("p",null,"Interpretation methods are very important responsible AI tools."),(0,l.kt)("p",null,"Partial dependence plots (PDP) and Individual Conditional Expectation (ICE) plots can be used to visualize and analyze interaction between the target response and a set of input features of interest."),(0,l.kt)("p",null,"PDP shows the dependence on average, and ICE shows the dependence in an individual sample level. This is important not only to help debug and understand how the model behaves but also is critical to Responsible AI. These methodologies facilitate driving transparency towards the users of the model and accountability by the model creators."),(0,l.kt)("p",null,"Using examples above we showed how to calculate and visualize such plots at a scalable manner to understand how a classification or regression model makes predictions, which features heavily impact the model, and how model prediction changes when feature value changes."))}u.isMDXComponent=!0}}]);